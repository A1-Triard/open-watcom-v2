/****************************************************************************
*
*                            Open Watcom Project
*
* Copyright (c) 2002-2020 The Open Watcom Contributors. All Rights Reserved.
*    Portions Copyright (c) 1983-2002 Sybase, Inc. All Rights Reserved.
*
*  ========================================================================
*
*    This file contains Original Code and/or Modifications of Original
*    Code as defined in and that are subject to the Sybase Open Watcom
*    Public License version 1.0 (the 'License'). You may not use this file
*    except in compliance with the License. BY USING THIS FILE YOU AGREE TO
*    ALL TERMS AND CONDITIONS OF THE LICENSE. A copy of the License is
*    provided with the Original Code and Modifications, and is also
*    available at www.sybase.com/developer/opensource.
*
*    The Original Code and all software distributed under the License are
*    distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
*    EXPRESS OR IMPLIED, AND SYBASE AND ALL CONTRIBUTORS HEREBY DISCLAIM
*    ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF
*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR
*    NON-INFRINGEMENT. Please see the License for the specific language
*    governing rights and limitations under the License.
*
*  ========================================================================
*
* Description:  Generate scaffolding for autogenerated option parsing.
*
****************************************************************************/


#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <stddef.h>
#include <locale.h>
#include "bool.h"
#include "lsspec.h"
#include "encodlng.h"
#include "cvttable.h"

#include "clibext.h"

#define OPT_TAGS \
TAG( ARGEQUAL ) \
TAG( CMT ) \
TAG( CODE ) \
TAG( INTERNAL ) \
TAG( PREFIX ) \
TAG( OPTION ) \
TAG( TARGET ) \
TAG( CHAIN ) \
TAG( CHAR ) \
TAG( ENUMERATE ) \
TAG( FILE ) \
TAG( GROUP ) \
TAG( ID ) \
TAG( IMMEDIATE ) \
TAG( JUSAGE ) \
TAG( JTITLE ) \
TAG( JTITLEU ) \
TAG( MULTIPLE ) \
TAG( NEGATE ) \
TAG( NOCHAIN ) \
TAG( NOEQUAL ) \
TAG( NTARGET ) \
TAG( NUMBER ) \
TAG( OPTIONAL ) \
TAG( PAGE ) \
TAG( PATH ) \
TAG( SPECIAL ) \
TAG( TIMESTAMP ) \
TAG( TITLE ) \
TAG( TITLEU ) \
TAG( USAGE ) \
TAG( USAGEGRP ) \
TAG( USAGEOGRP )

#define NEXT_ARG() \
        --argc1; ++argv1

#define NEXT_ARG_CHECK() \
        --argc1; ++argv1; if( argc1 < NUM_FILES ) { return( true ); }

// functions that are supplied by the host environment
#define FN_UNGET            "OPT_UNGET"                 // void ( void )
#define FN_GET_LOWER        "OPT_GET_LOWER"             // int ( void )
#define FN_RECOG            "OPT_RECOG"                 // bool ( int )
#define FN_RECOG_LOWER      "OPT_RECOG_LOWER"           // bool ( int )
#define FN_END              "OPT_END"                   // bool ( void )

#define FN_NUMBER           "OPT_GET_NUMBER"            // bool ( unsigned * )
#define FN_NUMBER_DEFAULT   "OPT_GET_NUMBER_DEFAULT"    // bool ( unsigned *, unsigned )
#define FN_NUMBER_MULTIPLE  "OPT_GET_NUMBER_MULTIPLE"   // bool ( OPT_NUMBER ** )
#define FN_CHAR             "OPT_GET_CHAR"              // bool ( int * )
#define FN_CHAR_OPT         "OPT_GET_CHAR_OPT"          // bool ( int * )
#define FN_ID               "OPT_GET_ID"                // bool ( OPT_STRING ** )
#define FN_ID_OPT           "OPT_GET_ID_OPT"            // bool ( OPT_STRING ** )
#define FN_FILE             "OPT_GET_FILE"              // bool ( OPT_STRING ** )
#define FN_FILE_OPT         "OPT_GET_FILE_OPT"          // bool ( OPT_STRING ** )
#define FN_PATH             "OPT_GET_PATH"              // bool ( OPT_STRING ** )
#define FN_PATH_OPT         "OPT_GET_PATH_OPT"          // bool ( OPT_STRING ** )

#define FN_CLEAN_STRING     "OPT_CLEAN_STRING"          // void ( OPT_STRING ** )
#define FN_CLEAN_NUMBER     "OPT_CLEAN_NUMBER"          // void ( OPT_NUMBER ** )

#define FN_PROCESS          "OPT_PROCESS"               // bool ( OPT_STORAGE * )
#define FN_INIT             "OPT_INIT"                  // void ( OPT_STORAGE * )
#define FN_FINI             "OPT_FINI"                  // void ( OPT_STORAGE * )

#define USE_SWITCH_THRESHOLD    (4)
#define CONSOLE_WIDTH           (79)

#define BUFF_SIZE               1024

#define HAS_OPT_STRING( o )     ( (o)->is_id || (o)->is_file || (o)->is_path || (o)->is_special )
#define HAS_OPT_NUMBER( o )     ( (o)->is_number && (o)->is_multiple )

#define NOCHAIN                 ((CHAIN *)(pointer_uint)-1)

#define mytolower(c)            ((c < 'A' || c > 'Z') ? c : c - 'A' + 'a')
#define myisspace(c)            (c == ' ' || c == '\t')

#define IS_SELECTED(s)          ((s->target & targetMask) && (s->ntarget & targetMask) == 0)

#define IS_ASCII(c)     (c < 0x80)

typedef int (*comp_fn)(const void *,const void *);

typedef void process_line_fn( language_id, const char *, bool );

typedef enum tag_id {
    #define TAG( s )        TAG_##s ,
    OPT_TAGS
    #undef TAG
    TAG_UNKNOWN,
    TAG_NULL
} tag_id;

typedef enum flow_control {
    EC_NULL             = 0,
    EC_CONTINUE         = 0x01,
    EC_CHAIN            = 0x02
} flow_control;

typedef enum cvt_name {
    CVT_NAME,
    CVT_PATTERN,
    CVT_USAGE
} cvt_name;

typedef struct target {
    struct target   *next;
    unsigned        mask;
    char            name[1];
} TARGET;

typedef struct name {
    struct name     *next;
    boolbit         is_timestamp : 1;
    char            name[1];
} NAME;

typedef struct title {
    struct title    *next;
    unsigned        target;
    unsigned        ntarget;
    boolbit         is_titleu   : 1;
    const char      *lang_title[LANG_MAX];
    const char      *lang_titleu[LANG_MAX];
} TITLE;

typedef struct chain {
    struct chain    *next;
    const char      *Usage[LANG_MAX];
    size_t          name_len;
    size_t          pattern_len;
    boolbit         usage_used : 1;
    boolbit         code_used  : 1;
    char            pattern[1];
} CHAIN;

typedef struct group {
    struct group    *next;
    const char      *Usage[LANG_MAX];
    char            pattern[1];
} GROUP;


typedef struct option {
    struct option   *next;
    struct option   *synonym;
    const char      *lang_usage[LANG_MAX];
    char            *check;
    char            *special;
    char            *special_arg_usage;
    char            *field_name;
    char            *value_field_name;
    NAME            *enumerate;
    char            *immediate;
    char            *code;
    unsigned        number_default;
    unsigned        target;
    unsigned        ntarget;
    boolbit         default_specified : 1;
    boolbit         is_simple         : 1;
    boolbit         is_immediate      : 1;
    boolbit         is_code           : 1;
    boolbit         is_internal       : 1;
    boolbit         is_multiple       : 1;
    boolbit         is_number         : 1;
    boolbit         is_id             : 1;
    boolbit         is_char           : 1;
    boolbit         is_file           : 1;
    boolbit         is_optional       : 1;
    boolbit         is_path           : 1;
    boolbit         is_special        : 1;
    boolbit         is_prefix         : 1;
    boolbit         is_timestamp      : 1;
    boolbit         is_negate         : 1;
    CHAIN           *chain;
    GROUP           *group;
    size_t          name_len;
    char            *name;
    char            pattern[1];
} OPTION;

typedef struct codeseq {
    struct codeseq  *sibling;
    struct codeseq  *children;
    OPTION          *option;
    char            c;
    boolbit         sensitive  : 1;
    boolbit         accept     : 1;
    boolbit         chain      : 1;
    boolbit         chain_root : 1;
} CODESEQ;

static unsigned     line;
static FILE         *gfp;
static FILE         *ofp;
static FILE         *pfp;
static FILE         *ufp;
static FILE         *mfp;
static FILE         *bfp;

static char         ibuff[BUFF_SIZE];
static char         tagbuff[BUFF_SIZE];
static char         tokbuff[BUFF_SIZE];
static char         tmpbuff[BUFF_SIZE];
static char         hdrbuff[BUFF_SIZE];
static char         maxusgbuff[BUFF_SIZE];

static char         alternateEqual;
static CHAIN        *lastChain;
static GROUP        *lastGroup;
static size_t       maxUsageLen;
static const char   *pageUsage[LANG_MAX];
static unsigned     targetMask;
static unsigned     targetAnyMask;
static unsigned     targetDbgMask;
static unsigned     nextTargetMask = 1;

static tag_id getsUsage = TAG_NULL;

static const char *tagNames[] = {
    #define TAG( s )        #s ,
    OPT_TAGS
    #undef TAG
    NULL
};

#define TAG( s )        static void do##s( const char * );
OPT_TAGS
#undef TAG

static void (*processTag[])( const char * ) = {
    #define TAG( s )        do##s ,
    OPT_TAGS
    #undef TAG
    NULL
};

static const char *validTargets[] = {
    "any",
    "dbg",
    "i86",
    "386",
    "axp",
    "ppc",
    "mps",
    "sparc",
    "bsd",
    "dos",
    "linux",
    "nt",
    "os2",
    "osx",
    "qnx",
    "haiku",
    "rdos",
    "targ1",
    "targ2",
    NULL
};

static const char * const langName[] = {
    #define LANG_DEF( id, dbcs )        #id ,
    LANG_DEFS
    #undef LANG_DEF
};

static uint_8 const langMaxChar[] = {
    #define LANG_DEF( id, dbcs )        dbcs ,
    LANG_DEFS
    #undef LANG_DEF
};

/*
 * Shift-JIS (CP932) lead byte ranges
 * 0x81-0x9F
 * 0xE0-0xFC
 */
static cvt_chr cvt_table_932[] = {
    #define pickb(s,u) {s, u},
    #define picki(s,u)
    #include "cp932uni.h"
    #undef picki
    #undef pickb
};

static const char *usageMsg[] = {
    "optencod [options] <gml-file> <parser-h> <parser-c> <usage-h> <target>*",
    "",
    "Options: (must appear in following order)",
    "  -i create international file with non-english data",
    "  -l <lang-n> is the language(number) used for output data",
    "  -n zero terminated items",
    "  -q quiet operation",
    "  -u <usage-u> is the output file for the QNX usage file",
    "  -utf8 output text use UTF-8 encoding",
    "",
    "    <gml-file> is the tagged input GML file",
    "    <parser-h> is the output file for the command line parser data declaration",
    "    <parser-c> is the output file for the command line parser code",
    "    <usage-h> is the output file for the usage string file",
    "    <target> can be chosen from:",
    NULL
};

static struct {
    boolbit     international   : 1;
    boolbit     quiet           : 1;
    boolbit     no_equal        : 1;
    boolbit     alternate_equal : 1;
    boolbit     zero_term       : 1;
    boolbit     out_utf8        : 1;
    language_id lang;
} optFlag;

static TARGET   *targetList;
static NAME     *enumList;
static NAME     *enumeratorList;
static OPTION   *optionList;
static OPTION   *uselessOptionList;
static TITLE    *titleList;
static CHAIN    *chainList;
static GROUP    *groupList = NULL;

static TITLE    *targetTitle;

static void emitCode( CODESEQ *h, unsigned depth, flow_control control );

static int mystricmp( const char *p1, const char *p2 )
{
    while( mytolower( *p1 ) == mytolower( *p2 ) ) {
        if( *p1 == '\0') {
            return( 0 );
        }
        p1++; p2++;
    }
    return( mytolower( *p1 ) - mytolower( *p2 ) );
}

#if 0
static int compare_enc( const cvt_chr *p1, const cvt_chr *p2 )
{
    return( p1->s - p2->s );
}
#endif

static int compare_utf8( const cvt_chr *p1, const cvt_chr *p2 )
{
    return( p1->u - p2->u );
}

static size_t utf8_to_cp932( const char *src, char *dst )
{
    size_t      i;
    size_t      o;
    size_t      src_len;
    cvt_chr     x;
    cvt_chr     *p;

    src_len = strlen( src );
    o = 0;
    for( i = 0; i < src_len && o < BUFF_SIZE - 6; i++ ) {
        x.u = (unsigned char)src[i];
        if( IS_ASCII( x.u ) ) {
            /*
             * ASCII (0x00-0x7F), no conversion
             */
            dst[o++] = (char)x.u;
        } else {
            /*
             * UTF-8 to UNICODE conversion
             */
            if( (x.u & 0xF0) == 0xE0 ) {
                x.u &= 0x0F;
                x.u = (x.u << 6) | ((unsigned char)src[++i] & 0x3F);
            } else {
                x.u &= 0x1F;
            }
            x.u = (x.u << 6) | ((unsigned char)src[++i] & 0x3F);
            /*
             * UNICODE to CP932 encoding conversion
             */
            p = bsearch( &x, cvt_table_932, sizeof( cvt_table_932 ) / sizeof( cvt_table_932[0] ), sizeof( cvt_table_932[0] ), (comp_fn)compare_utf8 );
            if( p == NULL ) {
                printf( "unknown unicode character: 0x%4.4X\n", x.u );
                x.s = '?';
            } else {
                x.s = p->s;
            }
            if( x.s > 0xFF ) {
                /* write lead byte first */
                dst[o++] = (char)(x.s >> 8);
            }
            dst[o++] = (char)x.s;
        }
    }
    dst[o] = '\0';
    return( o );
}

static const char *getLangUsage( const char *usage[], language_id lang )
{
    const char *p;

    p = usage[lang];
    if( p == NULL || *p == '\0' ) {
        p = usage[LANG_English];
    }
    return( p );
}

#if defined( __WATCOMC__ )
#pragma abort   fail
#endif
static void fail( const char *msg, ... )
{
    va_list args;

    if( line ) {
        fprintf( stderr, "error on line %u\n", line );
    }
    va_start( args, msg );
    vfprintf( stderr, msg, args );
    va_end( args );
    exit( EXIT_FAILURE );
}

static void dumpUsage( void )
{
    const char **p;

    for( p = usageMsg; *p != NULL; ++p ) {
        fprintf( stderr, "%s\n", *p );
    }
    fprintf( stderr, "        " );
    for( p = validTargets; *p != NULL; ++p ) {
        fprintf( stderr, "%s ", *p );
    }
    fprintf( stderr, "\n" );
}

static void emitPrintf( unsigned depth, const char *msg, ... )
{
    va_list args;
    unsigned i;

    if( pfp != NULL ) {
        for( i = ( depth >> 1 ); i != 0; --i ) {
            fprintf( pfp, "\t" );
        }
        if( depth & 1 ) {
            fprintf( pfp, "    " );
        }
        va_start( args, msg );
        vfprintf( pfp, msg, args );
        va_end( args );
    }
}

static void cvtOptionSpec( char *dst, const char *src, cvt_name cvt )
{
    char c;

    while( (c = *src++) != '\0' ) {
        if( c == '\\' ) {
            if( cvt == CVT_PATTERN ) {
                *dst++ = c;
            }
            c = *src++;
        } else if( cvt != CVT_USAGE ) {
            c = mytolower( c );
        }
        *dst++ = c;
    }
    *dst = c;
}

static bool cmpOptPattern( const char *pattern1, const char *pattern2 )
{
    char    c1;
    char    c2;

    for( ;; ) {
        c1 = *pattern1++;
        c2 = *pattern2++;
        if( c1 == '\\' ) {
            if( c2 != '\\' ) {
                return( false );
            }
            c1 = *pattern1++;
            c2 = *pattern2++;
        } else {
            c1 = mytolower( c1 );
            c2 = mytolower( c2 );
        }
        if( c1 != c2 ) {
            return( false );
        }
        if( c1 == '\0' ) {
            break;
        }
    }
    return( true );
}

static bool cmpChainPattern( const char *pattern1, const char *pattern2, size_t pattern_len )
{
    size_t  i;
    char    c1;
    char    c2;

    for( i = 0; i < pattern_len; ++i ) {
        c1 = *pattern1++;
        c2 = *pattern2++;
        if( c1 == '\\' ) {
            if( c2 != '\\' ) {
                return( false );
            }
            c1 = *pattern1++;
            c2 = *pattern2++;
        } else {
            c1 = mytolower( c1 );
            c2 = mytolower( c2 );
        }
        if( c1 != c2 ) {
            return( false );
        }
    }
    return( true );
}

static void addTarget( const char *t )
{
    size_t len;
    TARGET *p;

    len = strlen( t );
    p = malloc( sizeof( *p ) + len );
    p->mask = nextTargetMask;
    p->next = targetList;
    targetList = p;
    strcpy( p->name, t );
    nextTargetMask <<= 1;
    if( nextTargetMask == 0 ) {
        fail( "too many targets defined\n" );
    }
}

static unsigned findTarget( char const *t )
{
    TARGET *p;

    for( p = targetList; p != NULL; p = p->next ) {
        if( strcmp( t, p->name ) == 0 ) {
            return( p->mask );
        }
    }
    return( 0 );
}

static NAME *findName( NAME **h, const char *n )
{
    NAME *p;

    for( p = *h; p != NULL; p = p->next ) {
        if( strcmp( n, p->name ) == 0 ) {
            return( p );
        }
    }
    return( NULL );
}

static NAME *addName( NAME **h, const char *n )
{
    size_t len;
    NAME *p;

    len = strlen( n );
    p = malloc( sizeof(*p) + len );
    strcpy( p->name, n );
    p->next = *h;
    *h = p;
    return( p );
}

static NAME *addEnumerator( const char *enumerate, const char *field_name )
{
    NAME *n;

    strcpy( tmpbuff, "OPT_" );
    strcat( tmpbuff, enumerate );
    strcat( tmpbuff, "_" );
    strcat( tmpbuff, field_name );
    n = findName( &enumeratorList, tmpbuff );
    if( n == NULL ) {
        n = addName( &enumeratorList, tmpbuff );
    }
    return( n );
}

static GROUP *findGroup( const char *pattern )
{
    GROUP *gr;

    for( gr = groupList; gr != NULL; gr = gr->next ) {
        if( strcmp( gr->pattern, pattern ) == 0 ) {
            break;
        }
    }
    return( gr );
}

static GROUP *addGroup( const char *pattern )
{
    size_t  pattern_len;
    GROUP   *gr;

    if( findGroup( pattern ) != NULL ) {
        fail( "USAGEGRP: option '%s' already defined\n", pattern );
    }
    pattern_len = strlen( pattern );
    gr = calloc( 1, sizeof( *gr ) + pattern_len );
    memcpy( gr->pattern, pattern, pattern_len + 1 );
    if( groupList == NULL ) {
        groupList = gr;
    } else {
        lastGroup->next = gr;
    }
    lastGroup = gr;
    return( gr );
}

static CHAIN *findChain( const char *pattern )
{
    CHAIN *cn;

    for( cn = chainList; cn != NULL; cn = cn->next ) {
        if( cmpChainPattern( cn->pattern, pattern, cn->pattern_len ) ) {
            return( cn );
        }
    }
    return( NULL );
}

static CHAIN *addChain( char *pattern, bool chain )
{
    size_t pattern_len;
    CHAIN *cn;

    cvtOptionSpec( pattern, pattern, CVT_PATTERN );
    for( cn = chainList; cn != NULL; cn = cn->next ) {
        if( strcmp( pattern, cn->pattern ) == 0 ) {
            if( cn->code_used ) {
                fail( "CHAIN: option '%s' already defined\n", pattern );
            } else {
                fail( "USAGEOGRP: option '%s' already defined\n", pattern );
            }
        }
    }
    pattern_len = strlen( pattern );
    cn = calloc( 1, sizeof( *cn ) + pattern_len );
    cn->pattern_len = pattern_len;
    memcpy( cn->pattern, pattern, pattern_len + 1 );
    cvtOptionSpec( pattern, pattern, CVT_NAME );
    cn->name_len = strlen( pattern );
    cn->code_used = chain ? true : false;
    cn->next = chainList;
    chainList = cn;
    return( cn );
}

static FILE *initFILE( const char *fnam, const char *fmod )
{
    FILE        *fp;
    bool        open_read;

    fp = NULL;
    open_read = ( strchr( fmod, 'r' ) != NULL );
    if( open_read || fnam[0] != '.' || fnam[1] != '\0' ) {
        fp = fopen( fnam, fmod );
        if( fp == NULL ) {
            fail( "cannot open '%s' for %s", fnam, ( open_read ) ? "input" : "output" );
        }
    }
    return( fp );
}

#define NUM_FILES   4

static bool procCmdLine( int argc1, char **argv1 )
{
    const char  **t;
    unsigned    mask;
    char const  *p;

    if( argc1 < NUM_FILES ) {
        return( true );
    }
    if( strcmp( *argv1, "-i" ) == 0 ) {
        optFlag.international = true;
        NEXT_ARG_CHECK();
    }
    if( strcmp( *argv1, "-l" ) == 0 ) {
        NEXT_ARG_CHECK();
        optFlag.lang = atoi( *argv1 );
        NEXT_ARG_CHECK();
    }
    if( strcmp( *argv1, "-n" ) == 0 ) {
        optFlag.zero_term = true;
        NEXT_ARG_CHECK();
    }
    if( strcmp( *argv1, "-q" ) == 0 ) {
        optFlag.quiet = true;
        NEXT_ARG_CHECK();
    }
    if( strcmp( *argv1, "-u" ) == 0 ) {
        NEXT_ARG_CHECK();
        mfp = fopen( *argv1, "wb" );
        if( mfp == NULL )
            fail( "cannot open '%s' for output", *argv1 );
        NEXT_ARG_CHECK();
    }
    if( strcmp( *argv1, "-utf8" ) == 0 ) {
        optFlag.out_utf8 = true;
        NEXT_ARG_CHECK();
    }
    gfp = initFILE( *argv1, "r" );
    NEXT_ARG();
    ofp = initFILE( *argv1, "w+" );
    NEXT_ARG();
    pfp = initFILE( *argv1, "w+" );
    NEXT_ARG();
    ufp = initFILE( *argv1, "w+" );
    NEXT_ARG();
    for( t = validTargets; *t != NULL; ++t ) {
        addTarget( *t );
    }
    p = "any";
    if( (targetAnyMask = findTarget( p )) == 0 ) {
        fail( "invalid target name '%s'\n", p );
    }
    p = "dbg";
    if( (targetDbgMask = findTarget( p )) == 0 ) {
        fail( "invalid target name '%s'\n", p );
    }
    targetMask |= targetAnyMask;
    while( (p = *argv1) != NULL ) {
        if( (mask = findTarget( p )) == 0 ) {
            fail( "invalid target name '%s'\n", p );
        }
        targetMask |= mask;
        NEXT_ARG();
    }
    if( !optFlag.out_utf8 ) {
        qsort( cvt_table_932, sizeof( cvt_table_932 ) / sizeof( cvt_table_932[0] ), sizeof( cvt_table_932[0] ), (comp_fn)compare_utf8 );
    }
    return( false );
}

static size_t skipSpace( const char *start )
{
    const char  *p;

    for( p = start; *p != '\0'; ++p ) {
        if( !myisspace( *p ) ) {
            break;
        }
    }
    return( p - start );
}

static size_t copyNonSpaceUntil( const char *start, char *o, char t )
{
    const char  *i;

    for( i = start; *i != '\0'; ++i ) {
        if( myisspace( *i ) )
            break;
        if( *i == t ) {
            ++i;
            break;
        }
        *o = *i;
        ++o;
    }
    *o = '\0';
    return( i - start );
}

static tag_id findTag( char const *t )
{
    const char **c;

    for( c = tagNames; *c != NULL; ++c ) {
        if( mystricmp( t, *c ) == 0 ) {
            return( c - tagNames );
        }
    }
    return( TAG_UNKNOWN );
}

static tag_id isTag( const char **eot )
{
    tag_id tag;
    char *p;

    p = ibuff;
    p += skipSpace( p );
    if( *p == ':' ) {
        ++p;
        p += copyNonSpaceUntil( p, tagbuff, '.' );
        if( (tag = findTag( tagbuff )) == TAG_UNKNOWN )
            fail( "unknown tag: %s\n", tagbuff );
        *eot = p;
        return( tag );
    }
    return( TAG_NULL );
}

static OPTION *pushNewOption( char *pattern, OPTION *o )
{
    size_t  len;
    OPTION  *newo;

    len = strlen( pattern );
    newo = calloc( 1, sizeof( *newo ) + len );
    memcpy( newo->pattern, pattern, len + 1 );
    cvtOptionSpec( pattern, pattern, CVT_NAME );
    len = strlen( pattern );
    newo->name_len = len;
    newo->name = calloc( 1, len + 1 );
    memcpy( newo->name, pattern, len + 1 );
    newo->synonym = o;
    newo->is_simple = true;
    newo->next = optionList;
    optionList = newo;
    return( newo );
}

static char *pickUpRest( const char *p )
{
    size_t  len;
    char    *dst;
    char    *out;

    // replace leading '.' character by space
    // it is used to specify spaces on the beginning of text
    // if only '.' character than it is as blank text
    len = strlen( p );
    out = dst = malloc( len + 1 );
    if( p[0] == '.' ) {
        len--;
    }
    if( len > 0 ) {
        if( p[0] == '.' ) {
            *dst++ = ' ';
            p++;
        }
        memcpy( dst, p, len );
    }
    dst[len] = '\0';
    return( out );
}

// :argequal. <char>
static void doARGEQUAL( const char *p )
{
    p += skipSpace( p );
    if( *p == '\0' ) {
        fail( ":argequal. must have <char> specified\n" );
    } else {
        alternateEqual = *p;
        optFlag.alternate_equal = true;
    }
}

// :cmt comment text
static void doCMT( const char *p )
{
    /* unused parameters */ (void)p;
}

// :internal.
static void doINTERNAL( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_internal = true;
    }
}

// :option. <option> <synonym> ...
static void doOPTION( const char *p )
{
    OPTION *synonym;

    targetTitle = NULL;
    synonym = NULL;
    while( *p != '\0' ) {
        p += skipSpace( p );
        if( *p == '\0' )
            break;
        p += copyNonSpaceUntil( p, tokbuff, '\0' );
        synonym = pushNewOption( tokbuff, synonym );
    }
    getsUsage = TAG_OPTION;
}

// :target. <targ> <targ> ...
static void doTARGET( const char *p )
{
    unsigned mask;
    OPTION *o;

    while( *p != '\0' ) {
        p += skipSpace( p );
        if( *p == '\0' )
            break;
        p += copyNonSpaceUntil( p, tokbuff, '\0' );
        if( (mask = findTarget( tokbuff )) == 0 ) {
            fail( "invalid target name '%s'\n", tokbuff );
        }
        if( targetTitle != NULL ) {
            targetTitle->target |= mask;
        } else {
            for( o = optionList; o != NULL; o = o->synonym ) {
                o->target |= mask;
            }
        }
    }
}

// :ntarget. <targ> <targ> ...
static void doNTARGET( const char *p )
{
    unsigned mask;
    OPTION *o;

    while( *p != '\0' ) {
        p += skipSpace( p );
        if( *p == '\0' )
            break;
        p += copyNonSpaceUntil( p, tokbuff, '\0' );
        if( (mask = findTarget( tokbuff )) == 0 ) {
            fail( "invalid target name '%s'\n", tokbuff );
        }
        if( targetTitle != NULL ) {
            targetTitle->ntarget |= mask;
        } else {
            for( o = optionList; o != NULL; o = o->synonym ) {
                o->ntarget |= mask;
            }
        }
    }
}

// :number. [<fn>] [<default>]
static void doNUMBER( const char *p )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_number = true;
        o->is_simple = false;
    }
    p += skipSpace( p );
    if( *p != '\0' ) {
        p += copyNonSpaceUntil( p, tokbuff, '\0' );
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->check = strdup( tokbuff );
        }
        p += skipSpace( p );
        if( *p != '\0' ) {
            p += copyNonSpaceUntil( p, tokbuff, '\0' );
            for( o = optionList; o != NULL; o = o->synonym ) {
                o->number_default = atoi( tokbuff );
                o->default_specified = true;
            }
        }
    }
}

// :multiple.
static void doMULTIPLE( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_multiple = true;
    }
}

// :nochain.
static void doNOCHAIN( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->chain = NOCHAIN;
    }
}

// :id. [<fn>]
static void doID( const char *p )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_id = true;
        o->is_simple = false;
    }
    p += skipSpace( p );
    if( *p != '\0' ) {
        p += copyNonSpaceUntil( p, tokbuff, '\0' );
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->check = strdup( tokbuff );
        }
    }
}

// :char. [<fn>]
static void doCHAR( const char *p )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_char = true;
        o->is_simple = false;
    }
    p += skipSpace( p );
    if( *p != '\0' ) {
        p += copyNonSpaceUntil( p, tokbuff, '\0' );
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->check = strdup( tokbuff );
        }
    }
}

// :immediate. <fn>
static void doIMMEDIATE( const char *p )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_immediate = true;
        o->is_simple = false;
    }
    p += skipSpace( p );
    if( *p != '\0' ) {
        p += copyNonSpaceUntil( p, tokbuff, '\0' );
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->immediate = strdup( tokbuff );
        }
    } else {
        fail( ":immediate. must have <fn> specified\n" );
    }
}

// :code. <source-code>
static void doCODE( const char *p )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_code = true;
        o->is_simple = false;
    }
    p += skipSpace( p );
    if( *p != '\0' ) {
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->code = strdup( p );
        }
    } else {
        fail( ":immediate. must have <fn> specified\n" );
    }
}

// :file.
static void doFILE( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_file = true;
        o->is_simple = false;
    }
}

// :optional.
static void doOPTIONAL( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_optional = true;
    }
}
// :negate.
static void doNEGATE( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_negate = true;
        if( o->enumerate != NULL ){
            fail( "must be non-enumeration switch for negate tag\n" );
        }
    }
}


// :noequal.
static void doNOEQUAL( const char *p )
{
    /* unused parameters */ (void)p;

    optFlag.no_equal = true;
}

// :page. <text>
static void doPAGE( const char *p )
{
    pageUsage[LANG_English] = pickUpRest( p );
    getsUsage = TAG_PAGE;
}

// :path.
static void doPATH( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_path = true;
        o->is_simple = false;
    }
}

// :chain. <option> <usage>
//
// mark options that start with <option> as chainable
// i.e., -oa -ox == -oax
static void doCHAIN( const char *p )
{
    CHAIN *cn;

    p += skipSpace( p );
    if( *p == '\0' ) {
        fail( "missing <option> in :chain. tag\n" );
    }
    p += copyNonSpaceUntil( p, tokbuff, '\0' );
    cn = addChain( tokbuff, true );
    p += skipSpace( p );
    cn->Usage[LANG_English] = pickUpRest( p );
    lastChain = cn;
    getsUsage = TAG_CHAIN;
}

// :enumerate. <name> <option>
static void doENUMERATE( const char *p )
{
    NAME *n;
    OPTION *o;

    p += skipSpace( p );
    if( *p == '\0' ) {
        fail( "missing <name> in :enumerate. tag\n" );
    }
    p += copyNonSpaceUntil( p, tokbuff, '\0' );
    n = findName( &enumList, tokbuff );
    if( n == NULL ) {
        n = addName( &enumList, tokbuff );
    }
    tokbuff[0] = '\0';
    p += skipSpace( p );
    if( *p != '\0' ) {
        p += copyNonSpaceUntil( p, tokbuff, '\0' );
        addEnumerator( n->name, tokbuff );
    }
    addEnumerator( n->name, "default" );
    for( o = optionList; o != NULL; o = o->synonym ) {
        o->enumerate = n;
        if( o->is_timestamp ) {
            o->enumerate->is_timestamp = true;
        }
        if( tokbuff[0] != '\0' ) {
            o->field_name = strdup( tokbuff );
        }
    }
}

// :special. <fn>
static void doSPECIAL( const char *p )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_special = true;
        o->is_simple = false;
    }
    p += skipSpace( p );
    if( *p == '\0' ) {
        fail( "missing <fn> in :special. tag\n" );
    }
    p += copyNonSpaceUntil( p, tokbuff, '\0' );
    for( o = optionList; o != NULL; o = o->synonym ) {
        o->special = strdup( tokbuff );
    }
    p += skipSpace( p );
    if( *p != '\0' ) {
        p += copyNonSpaceUntil( p, tokbuff, '\0' );
        for( o = optionList; o != NULL; o = o->synonym ) {
            o->special_arg_usage = strdup( tokbuff );
        }
    }
}

// :prefix.
static void doPREFIX( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_prefix = true;
        o->is_simple = false;
    }
}

// :usage. <usage-text>
static void doUSAGE( const char *p )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->lang_usage[LANG_English] = pickUpRest( p );
    }
}

// :jusage. <kanji-usage-text>
static void doJUSAGE( const char *p )
{
    char *usage;
    OPTION *o;

    switch( getsUsage ) {
    case TAG_PAGE:
        pageUsage[LANG_Japanese] = pickUpRest( p );
        break;
    case TAG_CHAIN:
        lastChain->Usage[LANG_Japanese] = pickUpRest( p );
        break;
    case TAG_GROUP:
        lastGroup->Usage[LANG_Japanese] = pickUpRest( p );
        break;
    case TAG_OPTION:
        for( o = optionList; o != NULL; o = o->synonym ) {
            usage = pickUpRest( p );
            if( *usage == '\0' ) {
                free( usage );
                usage = strdup( o->lang_usage[LANG_English] );
            }
            o->lang_usage[LANG_Japanese] = usage;
        }
        break;
    default:
        fail( ":jusage. must follow :chain., :group., :option., or :page.\n" );
    }
}

// :title. <text>
static void doTITLE( const char *p )
{
    TITLE **i;
    TITLE *t;

    i = &titleList;
    for( t = *i; t != NULL; t = *i ) {
        i = &(t->next);
    }
    t = calloc( 1, sizeof( *t ) );
    t->next = *i;
    *i = t;
    t->target = 0;
    t->ntarget = 0;
    t->lang_title[LANG_English] = pickUpRest( p );
    targetTitle = t;
}

// :titleu. <text>
static void doTITLEU( const char *p )
{
    TITLE *t;

    t = targetTitle;
    if( t == NULL ) {
        fail( ":titleu. must follow a :title.\n" );
    }
    t->lang_titleu[LANG_English] = pickUpRest( p );
    t->is_titleu = true;
}

// :jtitle. <text>
static void doJTITLE( const char *p )
{
    TITLE *t;

    t = targetTitle;
    if( t == NULL ) {
        fail( ":jtitle. must follow a :title.\n" );
    }
    t->lang_title[LANG_Japanese] = pickUpRest( p );
}

// :jtitleu. <text>
static void doJTITLEU( const char *p )
{
    TITLE *t;

    t = targetTitle;
    if( t == NULL ) {
        fail( ":jtitleu. must follow a :title.\n" );
    }
    t->lang_titleu[LANG_Japanese] = pickUpRest( p );
    t->is_titleu = true;
}

// :group. <usagegrp>
static void doGROUP( const char *p )
{
    OPTION *o;
    GROUP  *gr;

    p += skipSpace( p );
    if( *p != '\0' ) {
        p += copyNonSpaceUntil( p, tokbuff, '\0' );
        gr = findGroup( tokbuff );
        if( gr != NULL ) {
            for( o = optionList; o != NULL; o = o->synonym ) {
                 o->group = gr;
            }
        }
    }
}


// :timestamp.
static void doTIMESTAMP( const char *p )
{
    OPTION *o;

    /* unused parameters */ (void)p;

    for( o = optionList; o != NULL; o = o->synonym ) {
        o->is_timestamp = true;
        o->is_simple = false;
        if( o->enumerate != NULL ) {
            o->enumerate->is_timestamp = true;
        }
    }
}

// :usageogrp. <option> <usage>
//
// mark options that start with <option> as group in usage text
// i.e., -fp0 -fp1 ==> -fp{0,1}
static void doUSAGEOGRP( const char *p )
{
    CHAIN *cn;

    p += skipSpace( p );
    if( *p == '\0' ) {
        fail( "missing <option> in :usageogrp. tag\n" );
    }
    p += copyNonSpaceUntil( p, tokbuff, '\0' );
    cn = addChain( tokbuff, false );
    p += skipSpace( p );
    cn->Usage[LANG_English] = pickUpRest( p );
    lastChain = cn;
    getsUsage = TAG_CHAIN;
}

// :usagegrp. <number> <usage>
//
// define group <number> with usage text for block of options
//
static void doUSAGEGRP( const char *p )
{
    GROUP *gr;

    p += skipSpace( p );
    if( *p == '\0' ) {
        fail( "missing <number> in :usagegrp. tag\n" );
    }
    p += copyNonSpaceUntil( p, tokbuff, '\0' );
    gr = addGroup( tokbuff );
    p += skipSpace( p );
    gr->Usage[LANG_English] = pickUpRest( p );
    lastGroup = gr;
    getsUsage = TAG_GROUP;
}

static void checkForGMLEscape( const char *p )
{
    bool is_escape;
    char c1, c2;

    c1 = *p++;
    if( c1 == '\0' || ! isalpha( c1 ) ) {
        return;
    }
    c2 = *p++;
    if( c2 == '\0' || ! isalpha( c2 ) ) {
        return;
    }
    is_escape = false;
    if( *p == '\0' || ! isalpha( *p ) ) {
        is_escape = true;
    }
    if( is_escape ) {
        fail( "possible GML escape sequence: &%c%c\n", c1, c2 );
    }
}

static void checkForGMLEscapeSequences( void )
{
    char c;
    char *p;

    for( p = ibuff; (c = *p++) != '\0'; ) {
        if( c == '&' ) {
            checkForGMLEscape( p );
        }
    }
}

static char *my_fgets( char *buff, int buff_len, FILE *fp )
{
    char    *p;
    size_t  len;

    p = fgets( buff, buff_len, fp );
    if( p != NULL ) {
        for( len = strlen( p ); len > 0 && ( p[len - 1] == '\n' || p[len - 1] == '\r' ); len-- )
            ;
        p[len] = '\0';
    }
    return( p );
}

static void readInputFile( void )
{
    const char  *eot;
    tag_id      tag;

    for( ; my_fgets( ibuff, sizeof( ibuff ), gfp ) != NULL; ) {
        ++line;
        checkForGMLEscapeSequences();
        tag = isTag( &eot );
        if( tag != TAG_NULL ) {
            eot += skipSpace( eot );
            (*processTag[tag])( eot );
        }
    }
}

static void checkForMissingUsages( void )
{
    OPTION *o;
    int start_lang;
    int end_lang;
    int i;

    if( optFlag.international ) {
        start_lang = 0;
        end_lang = LANG_MAX;
    } else {
        start_lang = LANG_English;
        end_lang = start_lang + 1;
    }
    for( o = optionList; o != NULL; o = o->next ) {
        if( o->chain == NULL || cmpOptPattern( o->pattern, o->chain->pattern ) ) {
            for( i = start_lang; i < end_lang; ++i ) {
                if( o->lang_usage[i] == NULL ) {
                    fail( "option '%s' has no %s usage\n", o->pattern, langName[i] );
                }
            }
        }
    }
}

static void assignChainToOptions( void )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->next ) {
        if( o->chain == NOCHAIN ) {
            o->chain = NULL;
        } else {
            o->chain = findChain( o->pattern );
        }
    }
}

static void stripUselessOptions( void )
{
    OPTION **h;
    OPTION *o;
    OPTION *o_next;

    h = &optionList;
    for( o = *h; o != NULL; o = o_next ) {
        o_next = o->next;
        if( IS_SELECTED( o ) ) {
            h = &(o->next);
        } else {
            o->next = uselessOptionList;
            uselessOptionList = o;
            *h = o_next;
        }
    }
}

static char *strpcpy( char *d, const char *s )
{
    size_t len;

    len = strlen( s );
    strcpy( d, s );
    return( d + len );
}

static char *special_char( char *f, char c )
{
    if( c == '~' ) {
        f = strpcpy( f, "_tilde" );
    } else if( c == '+' ) {
        f = strpcpy( f, "_plus" );
    } else if( c == '!' ) {
        f = strpcpy( f, "_exclamation" );
    } else if( c == '#' ) {
        f = strpcpy( f, "_sharp" );
    } else {
        *f++ = '_';
    }
    return( f );
}

static void makeFieldName( const char *pattern, char *f )
{
    char c;
    bool sensitive;
    bool special;

    c = *pattern++;
    if( c == '\\' ) {
        c = *pattern++;
    } else {
        c = mytolower( c );
    }
    if( c != '\0' ) {
        special = false;
        if( isalnum( c ) ) {
            if( isdigit( c ) )
                *f++ = '_';
            *f++ = c;
        } else {
            f = special_char( f, c );
            special = true;
        }
        sensitive = false;
        for( ; (c = *pattern++) != '\0'; ) {
            if( c == '\\' ) {
                sensitive = true;
                continue;
            }
            if( isalnum( c ) ) {
                if( special && *( f - 1 ) != '_' )
                    *f++ = '_';
                if( !sensitive )
                    c = mytolower( c );
                *f++ = c;
                special = false;
            } else {
                f = special_char( f, c );
                special = true;
            }
            sensitive = false;
        }
    }
    *f = '\0';
}

static void initOptionFields( void )
{
    OPTION *o;

    for( o = optionList; o != NULL; o = o->next ) {
        if( o->synonym == NULL ) {
            if( o->field_name == NULL ) {
                makeFieldName( o->pattern, tokbuff );
                o->field_name = strdup( tokbuff );
            }
            if( o->value_field_name == NULL ) {
                strcpy( tokbuff, o->field_name );
                strcat( tokbuff, "_value" );
                o->value_field_name = strdup( tokbuff );
            }
        }
    }
}

static void startParserH( void )
{
    OPTION *o;
    NAME *e;

    if( ofp != NULL ) {
        fprintf( ofp, "typedef struct opt_string OPT_STRING;\n" );
        fprintf( ofp, "struct opt_string {\n" );
        fprintf( ofp, "    OPT_STRING *next;\n" );
        fprintf( ofp, "    char data[1];\n" );
        fprintf( ofp, "};\n" );
        fprintf( ofp, "typedef struct opt_number OPT_NUMBER;\n" );
        fprintf( ofp, "struct opt_number {\n" );
        fprintf( ofp, "    OPT_NUMBER *next;\n" );
        fprintf( ofp, "    unsigned number;\n" );
        fprintf( ofp, "};\n" );
        fprintf( ofp, "typedef struct opt_storage OPT_STORAGE;\n" );
        fprintf( ofp, "struct opt_storage {\n" );
        fprintf( ofp, "    unsigned     timestamp;\n" );
        for( o = optionList; o != NULL; o = o->next ) {
            if( o->synonym == NULL ) {
                if( o->is_number ) {
                    if( HAS_OPT_NUMBER( o ) ) {
                        fprintf( ofp, "    OPT_NUMBER   *%s;\n", o->value_field_name );
                    } else {
                        fprintf( ofp, "    unsigned     %s;\n", o->value_field_name );
                    }
                } else if( o->is_char ) {
                    fprintf( ofp, "    int          %s;\n", o->value_field_name );
                } else if( HAS_OPT_STRING( o ) ) {
                    fprintf( ofp, "    OPT_STRING   *%s;\n", o->value_field_name );
                }
                if( o->is_timestamp ) {
                    if( o->enumerate == NULL ) {
                        fprintf( ofp, "    unsigned     %s_timestamp;\n", o->field_name );
                    }
                }
            }
        }
        for( e = enumList; e != NULL; e = e->next ) {
            fprintf( ofp, "    unsigned     %s;\n", e->name );
            if( e->is_timestamp ) {
                fprintf( ofp, "    unsigned     %s_timestamp;\n", e->name );
            }
        }
        for( o = optionList; o != NULL; o = o->next ) {
            if( o->synonym == NULL ) {
                if( o->enumerate == NULL ) {
                    fprintf( ofp, "    boolbit      %s : 1;\n", o->field_name );
                }
            }
        }
        fprintf( ofp, "};\n" );
    }
}

static void finishParserH( void )
{
    NAME *e;
    unsigned value;

    if( ofp != NULL ) {
        value = 0;
        for( e = enumeratorList; e != NULL; e = e->next ) {
            ++value;
            fprintf( ofp, "#define %s %u\n", e->name, value );
        }
    }
}

static CODESEQ *newCode( OPTION *o, char c, bool sensitive )
{
    CODESEQ *p;

    p = calloc( 1, sizeof( *p ) );
    p->option = o;
    p->c = c;
    p->sensitive = sensitive ? true : false;
    return( p );
}

static CODESEQ *addOptionCodeSeq( CODESEQ *code, OPTION *o )
{
    bool    sensitive;
    char    *pattern;
    char    c;
    CODESEQ *head;
    CODESEQ **splice;

    head = code;
    splice = &head;
    for( pattern = o->pattern; (c = *pattern++) != '\0'; ) {
        sensitive = false;
        if( c == '\\' ) {
            c = *pattern++;
            sensitive = true;
        } else {
            c = mytolower( c );
        }
        for( code = *splice; code != NULL; code = *splice ) {
            if( code->sensitive == sensitive ) {
                if( code->c == c ) {
                    break;
                }
            }
            splice = &(code->sibling);
        }
        if( code == NULL ) {
            code = newCode( o, c, sensitive );
            *splice = code;
        }
        splice = &(code->children);
    }
    if( code == NULL ) {
        code = newCode( o, '\0', false );
        *splice = code;
    }
    code->accept = true;
    code->option = o;
    return( head );
}

static CODESEQ *reorderCode( CODESEQ *c )
{
    CODESEQ *a;
    CODESEQ *h;
    CODESEQ *n;
    CODESEQ **s;

    h = c;
    if( c->sibling != NULL ) {
        a = NULL;
        s = &h;
        // accepting states move to the end
        for( c = h; c != NULL; c = n ) {
            n = c->sibling;
            if( c->accept ) {
                *s = n;
                c->sibling = a;
                a = c;
            } else {
                s = &(c->sibling);
            }
        }
        *s = a;
        s = &(h->sibling);
        // sensitive states move to the front
        for( c = h; c != NULL; c = n ) {
            n = c->sibling;
            if( c->sensitive ) {
                *s = n;
                c->sibling = h;
                h = c;
            } else {
                s = &(c->sibling);
            }
        }
    }
    for( c = h; c != NULL; c = c->sibling ) {
        if( c->children != NULL ) {
            c->children = reorderCode( c->children );
        }
    }
    return( h );
}

static bool markChainCode( CODESEQ *h, size_t level )
{
    CODESEQ *c;
    bool    rc;

    rc = false;
    for( c = h; c != NULL; c = c->sibling ) {
        if( c->option->chain != NULL && c->option->chain->code_used ) {
            if( c->children != NULL ) {
                if( level == c->option->chain->name_len ) {
                    if( markChainCode( c->children, level + 1 ) ) {
                        c->chain_root = true;
                    }
                }
            } else if( c->option->name_len == c->option->chain->name_len + 1 ) {
                c->chain = true;
                rc = true;
            }
        }
    }
    return( rc );
}

static CODESEQ *genCode( OPTION *o )
{
    CODESEQ *head;

    head = NULL;
    for( ; o != NULL; o = o->next ) {
        head = addOptionCodeSeq( head, o );
    }
    head = reorderCode( head );
    markChainCode( head, 1 );
    return( head );
}

static bool useSwitchStmt( CODESEQ *h )
{
    unsigned count;
    CODESEQ *c;

    count = 0;
    for( c = h; c != NULL; c = c->sibling ) {
        if( c->option->is_prefix ) {
            return( true );
        }
        ++count;
    }
    return( count >= USE_SWITCH_THRESHOLD );
}

static void emitSuccessCode( unsigned depth, flow_control control )
{
    if( control & EC_CONTINUE ) {
        emitPrintf( depth, "continue;\n" );
    } else {
        emitPrintf( depth, "return( false );\n" );
    }
}

static void emitAcceptCode( CODESEQ *c, unsigned depth, flow_control control )
{
    NAME *e;
    OPTION *o;
    struct {
        boolbit     close_value_if : 1;
    } flag;

    o = c->option;
    while( o->synonym != NULL ) {
        o = o->synonym;
    }
    if( o->is_prefix ) {
        emitPrintf( depth, "if( " FN_END "() ) {\n" );
        ++depth;
    }
    flag.close_value_if = false;
    if( o->is_number ) {
        if( o->default_specified ) {
            emitPrintf( depth, "if( " FN_NUMBER_DEFAULT "( &(data->%s ), %u ) ) {\n", o->value_field_name, o->number_default );
        } else if( o->is_multiple ) {
            emitPrintf( depth, "if( " FN_NUMBER_MULTIPLE "( &(data->%s ) ) ) {\n", o->value_field_name );
        } else {
            emitPrintf( depth, "if( " FN_NUMBER "( &(data->%s) ) ) {\n", o->value_field_name );
        }
        ++depth;
        flag.close_value_if = true;
    } else if( o->is_char ) {
        if( o->is_optional ) {
            emitPrintf( depth, "if( " FN_CHAR_OPT "( &(data->%s) ) ) {\n", o->value_field_name );
        } else {
            emitPrintf( depth, "if( " FN_CHAR "( &(data->%s) ) ) {\n", o->value_field_name );
        }
        ++depth;
        flag.close_value_if = true;
    } else if( o->is_id ) {
        if( o->is_optional ) {
            emitPrintf( depth, "if( " FN_ID_OPT "( &(data->%s) ) ) {\n", o->value_field_name );
        } else {
            emitPrintf( depth, "if( " FN_ID "( &(data->%s) ) ) {\n", o->value_field_name );
        }
        ++depth;
        flag.close_value_if = true;
    } else if( o->is_file ) {
        if( o->is_optional ) {
            emitPrintf( depth, "if( " FN_FILE_OPT "( &(data->%s) ) ) {\n", o->value_field_name );
        } else {
            emitPrintf( depth, "if( " FN_FILE "( &(data->%s) ) ) {\n", o->value_field_name );
        }
        ++depth;
        flag.close_value_if = true;
    } else if( o->is_path ) {
        if( o->is_optional ) {
            emitPrintf( depth, "if( " FN_PATH_OPT "( &(data->%s) ) ) {\n", o->value_field_name );
        } else {
            emitPrintf( depth, "if( " FN_PATH "( &(data->%s) ) ) {\n", o->value_field_name );
        }
        ++depth;
        flag.close_value_if = true;
    } else if( o->is_special ) {
        emitPrintf( depth, "if( %s( &(data->%s) ) ) {\n", o->special, o->value_field_name );
        ++depth;
        flag.close_value_if = true;
    }
    if( o->check != NULL ) {
        emitPrintf( depth, "%s( &(data->%s) );\n", o->check, o->value_field_name );
    }
    if( o->enumerate != NULL ) {
        e = addEnumerator( o->enumerate->name, o->field_name );
        if( o->is_timestamp ) {
            emitPrintf( depth, "data->%s_timestamp = ++(data->timestamp);\n", o->enumerate->name );
        }
        emitPrintf( depth, "data->%s = %s;\n", o->enumerate->name, e->name );
        if( o->is_immediate ) {
            emitPrintf( depth, "%s( data, true );\n", o->immediate );
        }
    } else {
        if( o->is_timestamp ) {
            emitPrintf( depth, "data->%s_timestamp = ++(data->timestamp);\n", o->field_name );
        }
        if( o->is_negate ) {
            emitPrintf( depth, "if( %s( '-' ) ) {\n", FN_RECOG );
            emitPrintf( depth+1, "data->%s = false;\n", o->field_name );
            if( o->is_immediate ) {
                emitPrintf( depth+1, "%s( data, false );\n", o->immediate );
            }
            emitPrintf( depth, "}else{\n" );
            emitPrintf( depth+1, "data->%s = true;\n", o->field_name );
            if( o->is_immediate ) {
                emitPrintf( depth+1, "%s( data, true );\n", o->immediate );
            }
            emitPrintf( depth, "}\n" );
        } else {
            emitPrintf( depth, "data->%s = true;\n", o->field_name );
            if( o->is_immediate ) {
                emitPrintf( depth, "%s( data, true );\n", o->immediate );
            }
        }
    }
    if( o->is_code ) {
        emitPrintf( depth, "%s;\n", o->code );
    }
    if( flag.close_value_if ) {
        --depth;
        emitPrintf( depth, "}\n" );
    }
    emitSuccessCode( depth, control );
    if( o->is_prefix ) {
        --depth;
        emitPrintf( depth, "}\n" );
        emitPrintf( depth, "break;\n" );
    }
}

static void emitCodeTree( CODESEQ *c, unsigned depth, flow_control control )
{
    if( c->children ) {
        if( c->chain ) {
            emitCode( c->children, depth, ( control & ~EC_CHAIN ) | EC_CONTINUE );
            if( c->accept ) {
                emitAcceptCode( c, depth, control & ~ EC_CONTINUE );
            } else {
                emitPrintf( depth, "return( true );\n" );
            }
        } else if( c->chain_root ) {
            emitCode( c->children, depth, control | EC_CHAIN | EC_CONTINUE );
            if( c->accept ) {
                emitAcceptCode( c, depth, control & ~ EC_CONTINUE );
            } else {
                emitSuccessCode( depth, control );
            }
        } else {
            emitCode( c->children, depth, control & ~EC_CHAIN );
            if( c->accept ) {
                emitAcceptCode( c, depth, control );
            } else {
                emitPrintf( depth, "return( true );\n" );
            }
        }
    } else {
        if( c->option->chain != NULL && c->option->chain->code_used ) {
            emitAcceptCode( c, depth, control );
        } else {
            emitAcceptCode( c, depth, control & ~ EC_CONTINUE );
        }
    }
}

static void emitIfCode( CODESEQ *c, unsigned depth, flow_control control )
{
    if( c->sensitive ) {
        emitPrintf( depth, "if( %s( '%c' ) ) {\n", FN_RECOG, c->c );
    } else {
        emitPrintf( depth, "if( %s( '%c' ) ) {\n", FN_RECOG_LOWER, c->c );
    }
    emitCodeTree( c, depth + 1, control );
    emitPrintf( depth, "}\n" );
}

static void emitCode( CODESEQ *h, unsigned depth, flow_control control )
{
    bool use_switch;
    CODESEQ *c;

    for( c = h; c != NULL; c = c->sibling ) {
        if( c->sensitive || (control & EC_CHAIN) && !c->chain ) {
            emitIfCode( c, depth, control );
        } else {
            break;
        }
    }
    if( c == NULL ) {
        return;
    }
    if( control & EC_CHAIN ) {
        emitPrintf( depth, "do {\n" );
        ++depth;
    }
    use_switch = useSwitchStmt( c );
    if( use_switch ) {
        emitPrintf( depth, "switch( " FN_GET_LOWER "() ) {\n" );
        ++depth;
    }
    for( ; c != NULL; c = c->sibling ) {
        if( use_switch ) {
            emitPrintf( depth - 1, "case '%c':\n", c->c );
            emitCodeTree( c, depth, control );
        } else {
            emitIfCode( c, depth, control );
        }
    }
    if( use_switch ) {
        --depth;
        emitPrintf( depth, "}\n" );
        emitPrintf( depth, FN_UNGET "();\n" );
    }
    if( control & EC_CHAIN ) {
        emitPrintf( depth, "break;\n" );
        --depth;
        emitPrintf( depth, "} while( ! " FN_END "() );\n" );
    }
}

static void outputFN_PROCESS( void )
{
    unsigned depth = 0;
    CODESEQ *codeseq;

    emitPrintf( depth, "bool " FN_PROCESS "( OPT_STORAGE *data )\n" );
    emitPrintf( depth, "{\n" );
    ++depth;
    codeseq = genCode( optionList );
    emitCode( codeseq, depth, EC_NULL );
    emitPrintf( depth, "return( true );\n" );
    --depth;
    emitPrintf( depth, "}\n" );
}

static void outputFN_INIT( void )
{
    OPTION *o;
    NAME *e;
    NAME *en;
    unsigned depth = 0;

    emitPrintf( depth, "void " FN_INIT "( OPT_STORAGE *data )\n" );
    emitPrintf( depth, "{\n" );
    ++depth;
    emitPrintf( depth, "memset( data, 0, sizeof( *data ) );\n" );
    for( o = optionList; o != NULL; o = o->next ) {
        if( o->synonym == NULL && o->is_number && o->default_specified ) {
            emitPrintf( depth, "data->%s = %u;\n", o->value_field_name, o->number_default );
        }
    }
    for( e = enumList; e != NULL; e = e->next ) {
        en = addEnumerator( e->name, "default" );
        emitPrintf( depth, "data->%s = %s;\n", e->name, en->name );
    }
    --depth;
    emitPrintf( depth, "}\n" );
}

static void outputFN_FINI( void )
{
    OPTION *o;
    unsigned depth = 0;

    emitPrintf( depth, "void " FN_FINI "( OPT_STORAGE *data )\n" );
    emitPrintf( depth, "{\n" );
    ++depth;
    for( o = optionList; o != NULL; o = o->next ) {
        if( o->synonym == NULL ) {
            if( HAS_OPT_STRING( o ) ) {
                emitPrintf( depth, FN_CLEAN_STRING "( &(data->%s) );\n", o->value_field_name );
            } else if( HAS_OPT_NUMBER( o ) ) {
                emitPrintf( depth, FN_CLEAN_NUMBER "( &(data->%s) );\n", o->value_field_name );
            }
        }
    }
    --depth;
    emitPrintf( depth, "}\n" );
}

static int usageCmp( const void *v1, const void *v2 )
{
    int     res;
    size_t  name_len;
    OPTION  *o1 = *(OPTION **)v1;
    OPTION  *o2 = *(OPTION **)v2;
    char    *n1 = o1->name;
    char    *n2 = o2->name;

    res = 0;
    if( o1->chain != o2->chain ) {
        if( o1->chain == NULL ) {
            name_len = o2->chain->name_len;
        } else if( o2->chain == NULL ) {
            name_len = o1->chain->name_len;
        } else if( o1->chain->name_len > o2->chain->name_len ) {
            name_len = o1->chain->name_len;
        } else {
            name_len = o2->chain->name_len;
        }
        res = strnicmp( n1, n2, name_len );
        if( res == 0 ) {
            res = strncmp( n1, n2, name_len );
            if( res == 0 ) {
                if( o1->chain == NULL ) {
                    return( 1 );
                }
                if( o2->chain == NULL ) {
                    return( -1 );
                }
                n1 += name_len;
                n2 += name_len;
            }
        }
    }
    if( res == 0 ) {
        res = mystricmp( n1, n2 );
        if( res == 0 ) {
            return( strcmp( n1, n2 ) );
        }
    }
    if( res < 0 ) {
        return( -1 );
    } else {
        return( 1 );
    }
}

static void catArg( char *arg )
{
    char *p;
    size_t len;

    len = strlen( tokbuff );
    p = &tokbuff[len];
    for( ; *arg != '\0'; ++arg ) {
        if( optFlag.no_equal ) {
            if( *arg != '=' ) {
                *p++ = *arg;
            }
        } else if( optFlag.alternate_equal ) {
            if( *arg != '=' ) {
                *p++ = *arg;
            } else {
                *p++ = alternateEqual;
            }
        } else {
            *p++ = *arg;
        }
    }
    *p = '\0';
}

static size_t genOptionUsageStart( OPTION *o )
{
    size_t  len;

    if( o->chain != NULL ) {
        tokbuff[0] = ' ';
        tokbuff[1] = ' ';
        tokbuff[2] = '\0';
        strcat( tokbuff, o->name + o->chain->name_len );
    } else {
        strcpy( tokbuff, "-" );
        cvtOptionSpec( tokbuff + 1, o->pattern, CVT_USAGE );
    }
    if( o->is_number ) {
        if( o->default_specified ) {
            catArg( "[=<num>]" );
        } else {
            catArg( "=<num>" );
        }
    } else if( o->is_char ) {
        if( o->is_optional ) {
            catArg( "[=<char>]" );
        } else {
            catArg( "=<char>" );
        }
    } else if( o->is_id ) {
        if( o->is_optional ) {
            catArg( "[=<id>]" );
        } else {
            catArg( "=<id>" );
        }
    } else if( o->is_file ) {
        if( o->is_optional ) {
            catArg( "[=<file>]" );
        } else {
            catArg( "=<file>" );
        }
    } else if( o->is_path ) {
        if( o->is_optional ) {
            catArg( "[=<path>]" );
        } else {
            catArg( "=<path>" );
        }
    } else if( o->is_negate ) {
        catArg( "[-]" );
    } else if( o->is_special ) {
        if( o->special_arg_usage != NULL ) {
            // we don't want special processing done
            strcat( tokbuff, o->special_arg_usage );
        }
    }
    len = strlen( tokbuff );
    return( len );
}

static void fillOutSpaces( char *buff, size_t n )
{
    char *p;

    p = &buff[strlen( buff )];
    while( n > 0 ) {
        *p++ = ' ';
        --n;
    }
    *p = '\0';
}

static bool usageValid( OPTION *o, language_id lang, GROUP *gr )
{
    const char  *usage;

    if( o->group != gr )
        return( false );
    if( o->synonym != NULL )
        return( false );
    if( o->is_internal && ( targetMask & targetDbgMask ) == 0 ) {
        return( false );
    }
    usage = o->lang_usage[lang];
    return( usage != NULL && usage[0] != '\0' );
}

static void emitUsageH( language_id lang, const char *str, bool page_flag )
{
    size_t len;
    const char *q;
    const char *s;

    /* unused parameters */ (void)lang;

    len = strlen( str );
    if( maxUsageLen < len ) {
        maxUsageLen = len;
        strcpy( maxusgbuff, str );
    }
    if( ufp != NULL ) {
        fprintf( ufp, "\"" );
        for( s = str; (q = strchr( s, '"' )) != NULL; s = q + 1 ) {
            // replace " with \"
            len = q - s;
            memcpy( tmpbuff, s, len );
            tmpbuff[len] = '\0';
            fprintf( ufp, "%s\\\"", tmpbuff );
        }
        fprintf( ufp, "%s%s\"\n", s, ( optFlag.zero_term ) ? "\\0" : "" );
    }

}

static void emitUsageHQNX( language_id lang, const char *str, bool page_flag )
{

    /* unused parameters */ (void)lang;

    if( mfp != NULL && !page_flag ) {
        fprintf( mfp, "%s\n", str );
    }

}

static char *createChainHeader( OPTION **o, language_id lang, size_t max )
{
    const char  *usage;
    CHAIN       *cn;
    size_t      len;

    cn = (*o)->chain;
    hdrbuff[0] = '-';
    cvtOptionSpec( hdrbuff + 1, cn->pattern, CVT_NAME );
    strcat( hdrbuff, "{" );
    len = 0;
    for( ; *o != NULL && (*o)->chain == cn; ++o ) {
        if( (*o)->chain != NULL ) {
            if( len > 0 ) {
                strcat( hdrbuff, "," );
            }
            genOptionUsageStart( *o );
            strcat( hdrbuff, &tokbuff[2] );
            ++len;
        }
    }
    usage = getLangUsage( cn->Usage, lang );
    strcat( hdrbuff, "} " );
    len = strlen( hdrbuff );
    if( len >= max ) {
        tokbuff[0] = '\0';
        fillOutSpaces( tokbuff, max/2 );
        strcat( tokbuff, usage );
        return( hdrbuff );
    } else {
        fillOutSpaces( hdrbuff, max - len );
        strcat( hdrbuff, usage );
        strcpy( tokbuff, hdrbuff );
        return( NULL );
    }
}

static void expand_tab( const char *s, char *d )
{
    for( ; *s != '\0'; ++s ) {
        if( s[0] == '\\' && s[1] == 't' ) {
            ++s;
            *d++ = ' ';
            *d++ = ' ';
            *d++ = ' ';
            *d++ = ' ';
            *d++ = ' ';
            *d++ = ' ';
            *d++ = ' ';
            *d++ = ' ';
        } else {
            *d++ = *s;
        }
    }
    *d = '\0';
}

#define TITLE_LEFT_MARGIN   8

static void outputTitle( const char *usage[], language_id lang, process_line_fn *process_line, bool center )
{
    const char  *p;
    size_t      len;

    p = getLangUsage( usage, lang );
    if( p != NULL && *p != '\0' ) {
        len = strlen( p );
        if( center && len < 80 ) {
            len = ( 80 - len ) / 2;
            if( len > TITLE_LEFT_MARGIN )
                len = TITLE_LEFT_MARGIN;
            tokbuff[0] = '\0';
            fillOutSpaces( tokbuff, len );
            strcat( tokbuff, p );
        } else {
            strcpy( tokbuff, p );
        }
        process_line( lang, tokbuff, true );
    }
}

static void createUsageHeader( const char *usage[], language_id lang, process_line_fn *process_line, bool center )
{
    const char  *title;
    TITLE       *t;

    outputTitle( usage, lang, process_line, center );

    for( t = titleList; t != NULL; t = t->next ) {
        if( IS_SELECTED( t ) ) {
            title = getLangUsage( t->lang_title, lang );
            expand_tab( title, tokbuff );
            process_line( lang, tokbuff, false );
            if( process_line == emitUsageH ) {
                title = getLangUsage( ( t->is_titleu ) ? t->lang_titleu : t->lang_title, lang );
                expand_tab( title, tokbuff );
                emitUsageHQNX( lang, tokbuff, false );
            }
        }
    }
}

static void clearChainUsage( void )
{
    CHAIN   *cn;

    for( cn = chainList; cn != NULL; cn = cn->next ) {
        cn->usage_used = false;
    }
}

static void processUsage( language_id lang, process_line_fn *process_line, GROUP *gr )
{
    unsigned    count;
    unsigned    i;
    size_t      max;
    size_t      len;
    OPTION      *o;
    OPTION      **t;
    OPTION      **c;
    char        *str;

    maxUsageLen = 0;
    max = 0;
    count = 0;
    for( o = optionList; o != NULL; o = o->next ) {
        if( usageValid( o, lang, gr ) ) {
            ++count;
            len = genOptionUsageStart( o );
            if( max < len ) {
                max = len;
            }
        }
    }
    ++max;
    t = calloc( count + 1, sizeof( OPTION * ) );
    c = t;
    for( o = optionList; o != NULL; o = o->next ) {
        if( usageValid( o, lang, gr ) ) {
            *c++ = o;
        }
    }
    *c = NULL;
    qsort( t, count, sizeof( OPTION * ), usageCmp );

    clearChainUsage();
    for( i = 0; i < count; ++i ) {
        o = t[i];
        if( o->chain != NULL && !o->chain->usage_used ) {
            o->chain->usage_used = true;
            str = createChainHeader( &t[i], lang, max );
            process_line( lang, tokbuff, false );
            if( str != NULL ) {
                process_line( lang, str, false );
            }
        }
        tokbuff[0] = '\0';
        len = genOptionUsageStart( o );
        if( len < max )
            fillOutSpaces( tokbuff, max - len );
        if( o->chain != NULL ) {
            strcat( tokbuff, "- " );
        }
        strcat( tokbuff, o->lang_usage[lang] );
        process_line( lang, tokbuff, false );
    }
    free( t );
    if( ( maxUsageLen / langMaxChar[lang] ) > CONSOLE_WIDTH ) {
        fprintf( stderr, "usage message exceeds %u chars\n%s\n", CONSOLE_WIDTH, maxusgbuff );
    }
}

static bool checkGroupUsed( language_id lang, GROUP *gr )
{
    OPTION  *o;

    for( o = optionList; o != NULL; o = o->next ) {
        if( usageValid( o, lang, gr ) ) {
            return( true );
        }
    }
    return( false );
}

static void outputUsageH( void )
{
    GROUP       *gr;

    createUsageHeader( pageUsage, optFlag.lang, emitUsageH, false );

    gr = NULL;
    processUsage( optFlag.lang, emitUsageH, gr );
    for( gr = groupList; gr != NULL; gr = gr->next ) {
        if( checkGroupUsed( optFlag.lang, gr ) ) {
            outputTitle( gr->Usage, optFlag.lang, emitUsageH, true );
            processUsage( optFlag.lang, emitUsageH, gr );
        }
    }
}

static void emitUsageB( language_id lang, const char *str, bool page_flag )
{
    size_t len;

    /* unused parameters */ (void)page_flag;

    if( lang == LANG_Japanese ) {
        if( !optFlag.out_utf8 ) {
            utf8_to_cp932( str, tmpbuff );
            str = tmpbuff;
        }
    }
    len = strlen( str ) + 1;
    fwrite( str, len, 1, bfp );
    if( maxUsageLen < len ) {
        maxUsageLen = len;
        strcpy( maxusgbuff, str );
    }
}

static void dumpInternational( void )
{
    language_id lang;
    char        fname[16];
    LocaleUsage usage_header;
    GROUP       *gr;

    for( lang = LANG_FIRST_INTERNATIONAL; lang < LANG_MAX; ++lang ) {
        sprintf( fname, "usage%02u." LOCALE_DATA_EXT, lang );
        bfp = fopen( fname, "wb" );
        if( bfp == NULL ) {
            fail( "cannot open international file for write\n" );
        }
        memset( &usage_header, 0, sizeof( usage_header ) );
        usage_header.header.code = LS_Usage;
        usage_header.header.signature = LS_Usage_SIG;
        fwrite( &usage_header, offsetof( LocaleUsage, data ), 1, bfp );

        createUsageHeader( pageUsage, lang, emitUsageB, false );

        gr = NULL;
        processUsage( lang, emitUsageB, gr );
        for( gr = groupList; gr != NULL; gr = gr->next ) {
            if( checkGroupUsed( lang, gr ) ) {
                outputTitle( gr->Usage, lang, emitUsageB, true );
                processUsage( lang, emitUsageB, gr );
            }
        }
        fputc( 0, bfp );
        fclose( bfp );
        bfp = NULL;
    }
}

static void closeFiles( void )
{
    fclose( gfp );
    if( mfp != NULL )
        fclose( mfp );
    if( ofp != NULL )
        fclose( ofp );
    if( pfp != NULL )
        fclose( pfp );
    if( ufp != NULL ) {
        fclose( ufp );
    }
}

int main( int argc, char **argv )
{
    bool    langs_ok;

    setlocale(LC_ALL,"C");
    langs_ok = _LANG_DEFS_OK();
    if( !langs_ok )
        fail( "language index mismatch\n" );
    if( procCmdLine( argc - 1, argv + 1 ) ) {
        dumpUsage();
        return( EXIT_FAILURE );
    }
    readInputFile();
    assignChainToOptions();
    checkForMissingUsages();
    stripUselessOptions();
    initOptionFields();

    startParserH();
    outputFN_PROCESS();
    outputFN_INIT();
    outputFN_FINI();
    finishParserH();
    outputUsageH();
    if( optFlag.international ) {
        dumpInternational();
    }
    closeFiles();
    return( EXIT_SUCCESS );
}
